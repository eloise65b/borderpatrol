import logging
import threading
import time
import pygame
import random 
import sqlite3
import sys
import pickle
import socket
import socketserver
import server

HOST = '127.0.0.1'  
PORT = 65432       


def send(data):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOST, PORT))
        s.sendall(b'data')
        

def recieve():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        data = s.recv(1024)
        return(data)

pygame.init()
conn = sqlite3.connect('data.db')
cursor = conn.cursor()
#note to self: this is NEEDED don't touch it, you'll break everything
clock = pygame.time.Clock()

def timerinit(refnum):
        taskdig1 = refnum[2]
        taskdig2 = refnum[3]
        taskdurationi = str("select TaskDuration from Task where TaskID like", taskID)
        taskduration = cursor.execute(taskdurationi)
    

def importperson(refnum):
        refnum = split(refnum)
        namedig1 = refnum[0]
        namedig2 = refnum[1]
        taskdig1 = refnum[2]
        taskdig2 = refnum[3]
        typedig1 = refnum[4]
        typedig2 = refnum[5]
        nameID = str(namedig1 + namedig2)
        
        firstnamei = str("select firstname from names where nameID like", nameID)
        firstname = cursor.execute(firstnamei)
        
        lastnamei = str("select lastname from names where nameID like", nameID)
        lastname = cursor.execute(lastnamei)
        
        taskID = str(taskdig1 + taskdig2)
        
        tasknamei = str("select TaskName from Task where TaskID like", taskID)
        taskname = cursor.execute(tasknamei)
        
        taskdurationi = str("select TaskDuration from Task where TaskID like", taskID)
        taskduration = cursor.execute(taskdurationi)
        
        taskscorei = str("select TaskScore from Task where TaskID like", taskID)
        taskscore = cursor.execute(taskscorei)
        
        typeID = str(typedig1 + typedig2)
        typenamei = ("select TypeName from Type where TypeID like", typeID)
        typename = cursor.execute(typenamei)

def split(word):
    return [char for char in word]

def populatewaitingroom():
    for i in range (0,5):
      refnum = generaterefnum()
      person = importperson(refnum)
      waitingroom.append(person)

def generaterefnum():
    #TODO: this
    name = choices(0,1,2,3,4,5,7,8,9,10,11,12,13,14,15)
    lenchoice = len(name)
    if lenchoice != 2:
        name = name + '0'

    task = choices(0,1,2,3,4,5)
    task = task + '0'
    type = choices(0,1,2,3,4,5) 
    type = type + '0'
    #TODO: this - make sure they are in range
    name = choices()
    task = choices()
    type = choices() 
    
    pass


#moved scheduling algorithms
def longestfirst():
    #x = number of tasks waiting
    x = 0
    #timeval = import from main string, time left on task
    for i in range(0,x):
        lowest = 1
        if timeval < lowest:
            lowest = timeval
            todo = x
    return(todo,x)

def shortestfirst():
    #x = number of tasks waiting
    x = 0
    #timeval = import from main string, time left on task
    for i in range(0,x):
        highest = 1
        if timeval > highest:
            highest = timeval
            todo = x
    return(todo,x) #unsure if this is appropriate- run within the func.?

def roundrobin(sleeptime):
    #must be called multiple times using a for statment? probably should run within the function
    x = 0
    for i in range(0,x):
        time.sleep(sleeptime)
        return(x)
        #what the hell is this though

        #TODO: please for the love of god redo these

def getname():
    for i in range (0,5):
     name = waitingroom[i]
     name = str(name)
    name = split(name)
    namedig1 = name[0]
    namedig2 = name[1]
    nameID = str(namedig1 + namedig2)


def getalltasks():
    for i in range (0,5):
     task = waitingroom[i]
     task = str(task)
     task = split(task)
     taskdig1 = task[2]
     taskdig2 = task[3]
     taskID = str(taskdig1 + taskdig2)
     taskname = str(["select TaskName from Task where TaskID like", TaskID])
     taskduration = str(["select TaskDuration from Task where TaskID like", TaskID])
    taskscore = str(["select TaskScore from Task where TaskID like", TaskID])

def instructions():
    #prints instructions to screen
    pass

def waitingroomdump():
    for i in range (0,5):
        refnum = waitingroom[i]
        refnum = split(refnum)
        namedig1 = refnum[0]
        namedig2 = refnum[1]
        taskdig1 = refnum[2]
        taskdig2 = refnum[3]
        typedig1 = refnum[4]
        typedig2 = refnum[5]
        nameID = str(namedig1 + namedig2)
        
        firstnamei = str("select firstname from names where nameID like", nameID)
        firstname = cursor.execute(firstnamei)
        
        lastnamei = str("select lastname from names where nameID like", nameID)
        lastname = cursor.execute(lastnamei)
        
        taskID = str(taskdig1 + taskdig2)
        
        tasknamei = str("select TaskName from Task where TaskID like", taskID)
        taskname = cursor.execute(tasknamei)
        
        taskdurationi = str("select TaskDuration from Task where TaskID like", taskID)
        taskduration = cursor.execute(taskdurationi)
        
        taskscorei = str("select TaskScore from Task where TaskID like", taskID)
        taskscore = cursor.execute(taskscorei)
        
        typeID = str(typedig1 + typedig2)
        typenamei = ("select TypeName from Type where TypeID like", typeID)
        typename = cursor.execute(typenamei)

        print(firstname, lastname, "is a", typename, "waiting for", taskname)
        

def setup():
    populatewaitingroom()
    setupdone = 1

def main():
    if setupdone == 0:
        setup()
    print("Game begin.")
    waitingroomdump()

#get reference number
waitingroom = []
currenttasks = []
setupdone = 0
main()

def movein(i):
    a = i-1
    movein = waitingroom.pop(a)
    currentasks.append(movein)
    
def moveout(i):
    a = i-1
    moveout = currentasks.pop(a)
    waitingroom.append(moveout)
    
 
 #TODO: 
 #generate refnum funtion - top priority 
 #use said lists to generate a second list of start times
 #time spent processing exceeds time needed, pass
 #time spent waiting exceeds wait time for person, fail task related to that person [use the reference numbers!!]
 #check per object per tick, maybe 60tps
 #then create a function to check whether waiting time is over and FAIL or task time is COMPLETE and pass
 
